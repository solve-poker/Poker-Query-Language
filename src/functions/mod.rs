use std::{
    iter::Filter,
    str::{Chars, FromStr},
};

use fn_macro::{pqlfn, pqlfn_fromstr};
use itertools::Itertools;
use lazy_static::lazy_static;
use rustc_hash::FxHashMap;
use vm::{VmBuffer, VmStack, VmStackValue, VmStore, VmStoreVarIdx, VmValue, *};

use crate::{
    eval_holdem7, eval_omaha9, eval_shortdeck7,
    prim::eval::{get_card_count, ARR_STRAIGHT, ARR_STRAIGHT_SHORT},
    Board, Card, Card64, DeadCards, Flop, FlopHandCategory, Hand, HandType,
    PQLBoardRange, PQLBoolean, PQLCard, PQLCardCount, PQLGame, PQLHiRating,
    PQLInteger, PQLRange, PQLRank, PQLRankSet, PQLStreet, Rank, Rank16, River,
    RuntimeError, Suit, Suit4, Turn, *,
};

mod outs_info;

mod cast;
pub use cast::*;

mod best_hi_rating;
mod board_in_range;
mod board_ranks;
mod board_suit_count;
mod duplicated_board_ranks;
mod duplicated_hand_ranks;
mod equity;
mod exact_flop_hand_category;
mod exact_hand_type;
mod five_card_hi_hand_number;
mod flop_hand_category;
mod flushing_board;
mod four_flush;
mod hand_board_intersections;
mod hand_ranks;
mod hand_type;
mod has_second_board_rank;
mod has_top_board_rank;
mod hi_rating;
mod in_range;
mod intersecting_hand_ranks;
mod max_rank;
mod min_flop_hand_category;
mod min_hand_type;
mod min_hi_rating;
mod min_outs_to_hand_type;
mod min_rank;
mod monotone_board;
mod nonintersecting_hand_ranks;
mod nth_rank;
mod nut_hi;
mod nut_hi_for_hand_type;
mod nut_hi_outs;
mod outs_to_hand_type;
mod overpair;
mod paired_board;
mod pocket_pair;
mod rainbow_board;
mod rank_count;
mod rate_hi_hand;
mod river_card;
mod scoops;
mod straight_board;
mod three_flush;
mod ties_hi;
mod turn_card;
mod twotone_board;
mod winning_hand_type;
mod wins_hi;

pub use best_hi_rating::best_hi_rating;
pub use board_in_range::board_in_range;
pub use board_ranks::board_ranks;
pub use board_suit_count::board_suit_count;
pub use duplicated_board_ranks::duplicated_board_ranks;
pub use duplicated_hand_ranks::duplicated_hand_ranks;
pub use equity::equity;
pub use exact_flop_hand_category::exact_flop_hand_category;
pub use exact_hand_type::exact_hand_type;
pub use five_card_hi_hand_number::five_card_hi_hand_number;
pub use flop_hand_category::flop_hand_category;
pub use flushing_board::flushing_board;
pub use four_flush::four_flush;
pub use hand_board_intersections::hand_board_intersections;
pub use hand_ranks::hand_ranks;
pub use hand_type::hand_type;
pub use has_second_board_rank::has_second_board_rank;
pub use has_top_board_rank::has_top_board_rank;
pub use hi_rating::hi_rating;
pub use in_range::in_range;
pub use intersecting_hand_ranks::intersecting_hand_ranks;
pub use max_rank::max_rank;
pub use min_flop_hand_category::min_flop_hand_category;
pub use min_hand_type::min_hand_type;
pub use min_hi_rating::min_hi_rating;
pub use min_outs_to_hand_type::min_outs_to_hand_type;
pub use min_rank::min_rank;
pub use monotone_board::monotone_board;
pub use nonintersecting_hand_ranks::nonintersecting_hand_ranks;
pub use nth_rank::nth_rank;
pub use nut_hi::nut_hi;
pub use nut_hi_for_hand_type::nut_hi_for_hand_type;
pub use nut_hi_outs::nut_hi_outs;
pub use outs_to_hand_type::outs_to_hand_type;
pub use overpair::overpair;
pub use paired_board::paired_board;
pub use pocket_pair::pocket_pair;
pub use rainbow_board::rainbow_board;
pub use rank_count::rank_count;
pub use rate_hi_hand::rate_hi_hand;
pub use river_card::river_card;
pub use scoops::scoops;
pub use straight_board::straight_board;
pub use three_flush::three_flush;
pub use ties_hi::ties_hi;
pub use turn_card::turn_card;
pub use twotone_board::twotone_board;
pub use winning_hand_type::winning_hand_type;
pub use wins_hi::wins_hi;

/// # Panics
/// board is always non-empty
#[inline]
fn max_rank_of_board(street: PQLStreet, board: Board) -> PQLRank {
    max_rank(board_ranks(street, board)).unwrap()
}

/// # Panics
/// board is always non-empty
#[inline]
fn fill_ratings(
    street: PQLStreet,
    (game, board, player_hands, ratings): (
        PQLGame,
        Board,
        &PlayerHands,
        &mut BufferRatings,
    ),
) {
    for (hand, rating) in player_hands.iter().zip(ratings.iter_mut()) {
        *rating = hi_rating(hand, street, (game, board));
    }
}

/// Trait for functions to be used in vm
///
/// Generated by `fn_macro::pqlfn`
/// Example:
/// ```ignore
/// #[pqlfn(arg, rtn, eval)]
/// pub fn hand_ranks(hand: &Hand, _street: PQLStreet) -> PQLRankSet;
///
/// pub trait PQLFnArgs {
///     fn arg_types(&self) -> &[PQLType] {
///         &[PQLType::Player, PQLType::Street]
///     }
/// }
///
/// pub trait PQLFnRtn {
///     fn rtn_type(&self) -> PQLType {
///         PQLType::RankSet
///     }
/// }
///
/// pub trait PQLFnEval {
///     fn evaluate(
///         &self,
///         buffer: &mut VmBuffer,
///         store: &mut VmStore,
///         stack: &mut VmStack,
///     ) -> Result<VmStackValue, PQLError> {
///         Ok(self(arg_range(buffer, store, stack), (&*buffer).into()).into())
///     }
/// }
/// ```
///
/// each pqlfn also generates a match arm for `FromStr` of &dyn `PQLFn`
/// ```ignore
///   "handranks" => Ok(&(hand_ranks as fn(&Hand, PQLStreet) -> PQLRankSet)),
/// ```
pub trait PQLFn:
    fmt::Debug + Send + Sync + PQLFnRtn + PQLFnArgs + PQLFnEval
{
}

impl<T> PQLFn for T where
    T: fmt::Debug + Send + Sync + PQLFnRtn + PQLFnArgs + PQLFnEval
{
}

pub trait PQLFnArgs {
    fn arg_types(&self) -> &[PQLType];
}

pub trait PQLFnRtn {
    fn rtn_type(&self) -> PQLType;
}

pub trait PQLFnEval {
    fn evaluate(
        &self,
        buffer: &mut VmBuffer,
        store: &mut VmStore,
        stack: &mut VmStack,
    ) -> Result<VmStackValue, PQLError>;
}

impl FromStr for &dyn PQLFn {
    type Err = ParseError;

    pqlfn_fromstr!();
}

fn arg_player<'b>(
    buffer: &'b VmBuffer,
    _store: &mut VmStore,
    stack: &mut VmStack,
) -> &'b Hand {
    let player: PQLPlayer = stack.downcast_pop().unwrap();

    let hand: &Hand = buffer.player_hand(player);

    hand
}

fn arg_str<'b>(
    _buffer: &VmBuffer,
    store: &'b VmStore,
    stack: &mut VmStack,
) -> &'b PQLString {
    let idx: VmStoreVarIdx = stack.downcast_pop().unwrap();
    let s: &PQLString = store.downcast_get(idx).unwrap();

    s
}

fn arg_range<'b, R>(
    _buffer: &VmBuffer,
    store: &'b mut VmStore,
    stack: &mut VmStack,
) -> &'b mut R
where
    &'b mut R: TryFrom<&'b mut VmValue>,
{
    let range_idx: VmStoreVarIdx = stack.downcast_pop().unwrap();

    store.downcast_get_mut(range_idx).unwrap()
}

const fn decompose_omaha(
    cards: Card64,
) -> (Card64, Card64, Card64, Card64, Card64, Card64) {
    let (v0, v1, v2, v3, v4, v5) = eval::decompose_omaha(cards.to_u64());

    (
        Card64::from_u64(v0),
        Card64::from_u64(v1),
        Card64::from_u64(v2),
        Card64::from_u64(v3),
        Card64::from_u64(v4),
        Card64::from_u64(v5),
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::*;

    #[quickcheck]
    fn test_decompose_omaha(cards: CardN<4>) {
        let vec: Vec<_> = cards.clone().into();
        let hands: [_; 6] = decompose_omaha(cards.into()).into();

        for cs in vec.into_iter().combinations(2) {
            assert!(hands.contains(&Card64::from(cs.as_ref())));
        }
    }
}
